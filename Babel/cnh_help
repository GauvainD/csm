
double scale_mul(double *a, double *b, int n)
{
  int i;
  double result = 0.0;
  for(i=0; i<n; ++i)
    result += a[i]*b[i];
  return(result);
}

void normalize_vector(double *vec) {
  int i;
  double tmp;
  tmp = sqrt(scale_mul(vec,vec,3));

  if(tmp == 0.0)
    tmp = 1.0;
  for (i=0; i<3; i++)
    vec[i] /= tmp;
}


double determinant(double R[3][3])
{
  double tmp = 0.0;

  tmp += R[0][0]*(R[1][1]*R[2][2]-R[1][2]*R[2][1]);
  tmp += R[0][1]*(R[1][2]*R[2][0]-R[1][0]*R[2][2]);
  tmp += R[0][2]*(R[1][0]*R[2][1]-R[1][1]*R[2][0]);
  return(tmp);
}


void cubic(double a, double b, double c, double *eigen_val)
{
  double p, q, a3, pp, cosalfa, alfa;

  if(fabs(a) < MINDOOUBLE && fabs(b) < MINDOOUBLE && fabs(c) < MINDOOUBLE)
    {
     eigen_val[0] = eigen_val[1] = eigen_val[2] = 0.0;
     return;
    }
  p   = -(a*a)/3.0+b;
  a3  = a/3.0;
  q   = 2.0*a3*a3*a3-a*b/3.0+c;
  pp  = -p/3.0;
  cosalfa = -0.5*q/sqrt(pp*pp*pp);  
  alfa    = acos(cosalfa);
printf("%.6f %.6f %.6f\n", a, b, c);

  if(cosalfa >  0.9999999999)
    alfa = 0.0;
  if(cosalfa < -0.9999999999)
    alfa = PI;
  eigen_val[0] = 2.0*sqrt(pp)*cos(alfa/3.0)-a3;
  eigen_val[1] = 2.0*sqrt(pp)*cos((alfa+2.0*PI)/3.0)-a3;
  eigen_val[2] = 2.0*sqrt(pp)*cos((alfa+4.0*PI)/3.0)-a3;
}



int min_abs_index(double *array, int n)
{
  int i, index;
  double current_min;

  current_min = fabs(array[0]);
  index = 0;
  for(i=1; i < n; ++i)
    if(fabs(array[i]) < current_min)
      {
	current_min = fabs(array[i]);
	index = i;
      }
  return(index);
}

void calcRefPlaneCNH(double *parray[], int **orbits, int orbit_number,                   
                    double dir_cos_min[3],double *sym_min)
{
  int i, j, k, index, best_j;
  double a, b, c;
  double coef[3][3]={{.0,.0,.0},{.0,.0,.0},{.0,.0,.0}},
             tmp[3][3]={{.0,.0,.0},{.0,.0,.0},{.0,.0,.0}};
  double dir_cos[6][3];
  double eigen_val[3]={.0,.0,.0};
  double comp_det[3][3]={{.0,.0,.0},{.0,.0,.0},{.0,.0,.0}};
  double dir_cos1[3][3]={{.0,.0,.0},{.0,.0,.0},{.0,.0,.0}};
  double vector_b[3] = {.0,.0,.0};
  double f[3], f1, f2, f3, l1, l2, l3;
  double rtr[7], rti[7], optimal_root;
  double tetta, sin_tetta,cos_tetta, l_ntb_2, sum=.0, sum2=.0;
  int orbit_n, pair_n, element_n, atom, next_atom, next_index,
      orbit_n2;
  double poly_c[7];
  double eigen_val_max;
  double max_val, sym;


 /*********************************/
 /*         cn-related part       */
 /*********************************/


  for(orbit_n = 0; orbit_n < orbit_number; ++orbit_n)
     {
     if(orbit_n%2 == 0)
        orbit_n2 = orbit_n+1;
     else
        orbit_n2 = orbit_n-1;

     for(element_n=0; element_n<opOrder; ++element_n)
        {
         tetta = (2.*PI*element_n)/opOrder;
         cos_tetta = cos(tetta);
         sin_tetta = sin(tetta); 


/*********************************/
/*         cn-related part       */
/*********************************/


         for(pair_n = 0; pair_n < opOrder; ++pair_n)
	    {
            atom       = orbits[orbit_n][pair_n];
            next_index = (pair_n+element_n)%opOrder;
            next_atom  = orbits[orbit_n][next_index];
	printf("atom %d nextAtom %d\n", atom, next_atom);
	

            sum       += (scale_mul(parray[atom],parray[next_atom],3)*cos_tetta);

	    coef[0][0] += 2.0*parray[atom][0]*parray[next_atom][0]*(1.-cos_tetta);
	    coef[1][1] += 2.0*parray[atom][1]*parray[next_atom][1]*(1.-cos_tetta);
	    coef[2][2] += 2.0*parray[atom][2]*parray[next_atom][2]*(1.-cos_tetta);
printf("pos: parray[atom][0] %.6f, parray[next][0] = %.6f\n", parray[atom][0], parray[next_atom][0]);
	    coef[1][0] += (parray[atom][0]*parray[next_atom][1]+
			   parray[atom][1]*parray[next_atom][0])*(1.-cos_tetta);
	    coef[2][0] += (parray[atom][0]*parray[next_atom][2]+
			   parray[atom][2]*parray[next_atom][0])*(1.-cos_tetta);
	    coef[2][1] += (parray[atom][1]*parray[next_atom][2]+
	                   parray[atom][2]*parray[next_atom][1])*(1.-cos_tetta);
	        
	    vector_b[0] += (parray[atom][1]*parray[next_atom][2]-
	                    parray[atom][2]*parray[next_atom][1])*sin_tetta;
	    vector_b[1] -= (parray[atom][0]*parray[next_atom][2]-
	                    parray[atom][2]*parray[next_atom][0])*sin_tetta;
	    vector_b[2] += (parray[atom][0]*parray[next_atom][1]-
	                    parray[atom][1]*parray[next_atom][0])*sin_tetta;	    
            }

/*******************************************/
/*         cn*(cs,ci) -related part       */
/******************************************/


          for(pair_n = 0; pair_n < opOrder; ++pair_n)
             {
             if(opOrder%2 == 0)
	       {
                atom       = orbits[orbit_n][pair_n];
                next_index = (pair_n+element_n+opOrder/2)%opOrder;
                next_atom  = orbits[orbit_n2][next_index];

                sum2       -= (scale_mul(parray[atom],parray[next_atom],3)*cos_tetta);

	        coef[0][0] -=  2.0*parray[atom][0]*parray[next_atom][0]*(1.-cos_tetta);
	        coef[1][1] -=  2.0*parray[atom][1]*parray[next_atom][1]*(1.-cos_tetta);
	        coef[2][2] -=  2.0*parray[atom][2]*parray[next_atom][2]*(1.-cos_tetta);
	        coef[1][0] -=  (parray[atom][0]*parray[next_atom][1]+
			        parray[atom][1]*parray[next_atom][0])*(1.-cos_tetta);
	        coef[2][0]  -= (parray[atom][0]*parray[next_atom][2]+
			        parray[atom][2]*parray[next_atom][0])*(1.-cos_tetta);
	        coef[2][1]  -= (parray[atom][1]*parray[next_atom][2]+
	                        parray[atom][2]*parray[next_atom][1])*(1.-cos_tetta);
	        
	        vector_b[0] -= (parray[atom][1]*parray[next_atom][2]-
	                        parray[atom][2]*parray[next_atom][1])*sin_tetta;
	        vector_b[1] += (parray[atom][0]*parray[next_atom][2]-
	                        parray[atom][2]*parray[next_atom][0])*sin_tetta;
	        vector_b[2] -= (parray[atom][0]*parray[next_atom][1]-
	                        parray[atom][1]*parray[next_atom][0])*sin_tetta;

                }
              else
                {
                atom       = orbits[orbit_n][pair_n];
                next_index = (pair_n+element_n)%opOrder;
                next_atom  = orbits[orbit_n2][next_index];

                sum2      += (scale_mul(parray[atom],parray[next_atom],3)*cos_tetta);

                coef[0][0] -=  2.0*parray[atom][0]*parray[next_atom][0]*(1.+cos_tetta);
                coef[1][1] -=  2.0*parray[atom][1]*parray[next_atom][1]*(1.+cos_tetta);
                coef[2][2] -=  2.0*parray[atom][2]*parray[next_atom][2]*(1.+cos_tetta);
                coef[1][0] -= (parray[atom][0]*parray[next_atom][1]+
                               parray[atom][1]*parray[next_atom][0])*(1.+cos_tetta);
                coef[2][0] -= (parray[atom][0]*parray[next_atom][2]+
                               parray[atom][2]*parray[next_atom][0])*(1.+cos_tetta);
                coef[2][1] -= (parray[atom][1]*parray[next_atom][2]+
                               parray[atom][2]*parray[next_atom][1])*(1.+cos_tetta);

                vector_b[0] += (parray[atom][1]*parray[next_atom][2]-
                                parray[atom][2]*parray[next_atom][1])*sin_tetta;
                vector_b[1] -= (parray[atom][0]*parray[next_atom][2]-
                                parray[atom][2]*parray[next_atom][0])*sin_tetta;
                vector_b[2] += (parray[atom][0]*parray[next_atom][1]-
                                parray[atom][1]*parray[next_atom][0])*sin_tetta;
                }
            }
	}	
    }

  coef[0][1] = coef[1][0];
  coef[0][2] = coef[2][0];
  coef[1][2] = coef[2][1];
printf("%.6f %.6f %.6f\n", coef[0][0], coef[0][1], coef[0][2]);
printf("%.6f %.6f %.6f\n", coef[1][0], coef[1][1], coef[1][2]);
printf("%.6f %.6f %.6f\n", coef[2][0], coef[2][1], coef[2][2]);
printf("%.6f %.6f %.6f\n", vector_b[0], vector_b[1], vector_b[2]);

  a = -(coef[0][0]+coef[1][1]+coef[2][2]);
  b =  (coef[0][0]*coef[1][1]-coef[1][0]*coef[0][1])+
    (coef[0][0]*coef[2][2]-coef[2][0]*coef[0][2])+
    (coef[1][1]*coef[2][2]-coef[1][2]*coef[2][1]);
  c = -determinant(coef);
printf("%.6f %.6f %.6f\n", a, b, c);

  cubic(a, b, c, eigen_val);

  eigen_val_max=- MAXDOUBLE;
  for (i=0; i<3; i++) {
	printf("%.6f\n", eigen_val[i]);
     if(eigen_val_max < eigen_val[i])
        eigen_val_max = eigen_val[i];
  }	

  for (i=0; i<3; i++)
    for (j=0; j<3; j++)
      tmp[i][j] = coef[i][j];

  /* loop along eigen values */

  for(k=0; k<3; ++k)
    {
      int k1,k2;

      k1=(k+1)%3; /* k1 is next - after k  */
      k2=(k+2)%3; /* k2 is next - after k1 */

      for(i=0; i<3; i++)
	tmp[i][i] = coef[i][i] - eigen_val[k];

      comp_det[0][0] =  (tmp[1][1]*tmp[2][2]-tmp[1][2]*tmp[2][1]);
      comp_det[1][1] =  (tmp[0][0]*tmp[2][2]-tmp[0][2]*tmp[2][0]);
      comp_det[2][2] =  (tmp[0][0]*tmp[1][1]-tmp[0][1]*tmp[1][0]);
      comp_det[0][1] = -(tmp[1][0]*tmp[2][2]-tmp[2][0]*tmp[1][2]);
      comp_det[0][2] =  (tmp[1][0]*tmp[2][1]-tmp[2][0]*tmp[1][1]);
      comp_det[1][2] = -(tmp[0][0]*tmp[2][1]-tmp[2][0]*tmp[0][1]);
      comp_det[1][0] = comp_det[0][1];
      comp_det[2][0] = comp_det[0][2];
      comp_det[2][1] = comp_det[1][2];

      if(fabs(vector_b[0]) > MINDOOUBLE || fabs(vector_b[1]) > MINDOOUBLE || 
	 fabs(vector_b[2]) > MINDOOUBLE)
	{

	  /* elegant programming if IF: cheking 3 eigen_val - 0, 1, 2
	     here %3 (reminder of deviding by 3) is to choose two others, than k: 
	     for k==0 ->1,2 for k==1->2,0 for k==2->0,1 */

	  /* checking that there are two euqal and one different eigen_values */

	  if( fabs(eigen_val[k]  - eigen_val[k1]) > MINDOOUBLE &&
	      fabs(eigen_val[k1] - eigen_val[k2]) < MINDOOUBLE)
	    {
	      double a,b,g;

	      max_val=0.0;
	      best_j = 0;
	      for(i=0; i<3; ++i)
		for(j=0; j<3; ++j)
		  if(max_val < fabs(comp_det[i][j]))
		    {
		      max_val = fabs(comp_det[i][j]);
		      best_j = j;
		    }

	      dir_cos1[k][0] = comp_det[0][best_j];
	      dir_cos1[k][1] = comp_det[1][best_j];
	      dir_cos1[k][2] = comp_det[2][best_j];

	      index = min_abs_index(dir_cos1[k], 3);

	      a=dir_cos1[k][0]; b=dir_cos1[k][1]; g=dir_cos1[k][2];
	      /* creating two others orthogonal vectors */
	      switch(index)
		{
		case 0:
		  dir_cos1[k1][0]=0.0; 
		  dir_cos1[k1][1]=g; 
		  dir_cos1[k1][2]=-b;
		  dir_cos1[k2][0]=-(g*g+b*b); 
		  dir_cos1[k2][1]=a*b; 
		  dir_cos1[k2][2]=a*g;
		  break;
		case 1:
		  dir_cos1[k1][0]=g; 
		  dir_cos1[k1][1]=0.0; 
		  dir_cos1[k1][2]=-a;
		  dir_cos1[k2][0]=-a*b; 
		  dir_cos1[k2][1]=a*a+g*g; 
		  dir_cos1[k2][2]=-b*g;
		  break;
		case 2:
		  dir_cos1[k1][0]=b; 
		  dir_cos1[k1][1]=-a; 
		  dir_cos1[k1][2]=0.0;
		  dir_cos1[k2][0]=a*g; 
		  dir_cos1[k2][1]=b*g; dir_cos1[k2][2]=-(a*a+b*b);
		  break;
		}
	      normalize_vector(dir_cos1[0]);
	      normalize_vector(dir_cos1[1]);
	      normalize_vector(dir_cos1[2]);
	      
	      break;
	    }
	  else
	    /* checking that all 3 eigen_values are the same */

	    if(fabs(eigen_val[k] - eigen_val[k1]) < MINDOOUBLE &&
	       fabs(eigen_val[k1]- eigen_val[k2]) < MINDOOUBLE &&
	       fabs(eigen_val[k] - eigen_val[k2]) < MINDOOUBLE )
	      {
		dir_cos[0][0]=-vector_b[0];
		dir_cos[0][1]=-vector_b[1];
		dir_cos[0][2]=-vector_b[2];
		normalize_vector(dir_cos[0]);
		return;
	      }

	    else /* all 3 eigen_values are different from each other */
	      {
		max_val=0.0;
		best_j = 0;
		for(i=0; i<3; ++i)
		  for(j=0; j<3; ++j)
		    if(max_val < fabs(comp_det[i][j]))
		      {
			max_val = fabs(comp_det[i][j]);
			best_j = j;
		      }

		dir_cos1[k][0] = comp_det[0][best_j];
		dir_cos1[k][1] = comp_det[1][best_j];
		dir_cos1[k][2] = comp_det[2][best_j];

		normalize_vector(dir_cos1[0]);
		normalize_vector(dir_cos1[1]);
		normalize_vector(dir_cos1[2]);
	      }

	}/* end of if( fabs(b) > 0) */
      else /* abs(b) is close to zero */
	{
	  /* checks is the current eigen_val maximal */

	  if(eigen_val[k] > eigen_val[k1] && eigen_val[k] > eigen_val[k2])
	    {
	      max_val=0.0;
	      best_j = 0;
	      for(i=0; i<3; ++i)
		for(j=0; j<3; ++j)
		  if(max_val < fabs(comp_det[i][j]))
		    {
		      max_val = fabs(comp_det[i][j]);
		      best_j = j;
		    }

	      dir_cos[0][0] = comp_det[0][best_j];
	      dir_cos[0][1] = comp_det[1][best_j];
	      dir_cos[0][2] = comp_det[2][best_j];

	      normalize_vector(dir_cos[0]);
	      printf("sum %.6f  sum2 %.6f, eigen_val_max %.6f\n", sum, sum2, eigen_val_max);
	      printf("order %d orbitNumber %d\n", opOrder, orbit_number);

              sym = 2.0*(1.0-(sum+sum2+0.5*(eigen_val_max))/(2. * opOrder * orbit_number * opOrder));

              *sym_min = fabs(100 * sym); 
              dir_cos_min[0]=dir_cos[0][0];
              dir_cos_min[1]=dir_cos[0][1];
              dir_cos_min[2]=dir_cos[0][2];
	      return;
	    }
	}
    } /*end of loop along eigen_values*/


  for(k=0; k<3; ++k)
    f[k] = scale_mul(vector_b,dir_cos1[k],3);

  f1 = f[0]*f[0]; f2 = f[1]*f[1]; f3 = f[2]*f[2];
  l1 = eigen_val[0]; l2 = eigen_val[1]; l3 = eigen_val[2];

  a=l1+l2+l3; b=l1*l2+l1*l3+l2*l3; c=l1*l2*l3;
  poly_c[0] = 1.0;
  poly_c[1] = -2.0*a;
  poly_c[2] = a*a + 2.0*b;
  poly_c[3] = -2.0*(a*b+c);
  poly_c[4] = 2.0*a*c+b*b;
  poly_c[5] = -2.0*b*c;
  poly_c[6] = c*c;

  poly_c[2] -= (f1+f2+f3);
  poly_c[3] += 2.0*(f1*(l2+l3)+f2*(l1+l3)+f3*(l1+l2));
  poly_c[4] -= (f1*(l2*l2+l3*l3+4*l2*l3)+
		f2*(l1*l1+l3*l3+4*l1*l3)+
		f3*(l1*l1+l2*l2+4*l1*l2) );
  poly_c[5] += 2.0*(f1*l2*l3*(l2+l3)+
		    f2*l1*l3*(l1+l3)+
		    f3*l1*l2*(l1+l2));
  poly_c[6] -= f1*l2*l2*l3*l3+f2*l1*l1*l3*l3+f3*l1*l1*l2*l2;

  rpoly(poly_c, 6, rtr, rti);

  /* choose optimal root procedure */

  *sym_min = 100.0;
  for(k=1; k<7; ++k)
    {
    if(fabs(rti[k]) < MINDOOUBLE)
      {
	optimal_root = rtr[k];

	for(i=0; i<3; ++i)
	  {
	    double denominator;

	    denominator = eigen_val[i] - optimal_root;
	    if(fabs(denominator) < MINDOOUBLE)
	      {
		dir_cos[k-1][0]=dir_cos1[i][0];
		dir_cos[k-1][1]=dir_cos1[i][1];
		dir_cos[k-1][2]=dir_cos1[i][2];
		break;
	      }

	    dir_cos[k-1][0] += dir_cos1[i][0]*f[i]/denominator;
	    dir_cos[k-1][1] += dir_cos1[i][1]*f[i]/denominator;
	    dir_cos[k-1][2] += dir_cos1[i][2]*f[i]/denominator;
	  }
	normalize_vector(dir_cos[k-1]);

        l_ntb_2 = 0.5*(optimal_root - scale_mul(vector_b,dir_cos[k-1],3));
        sym = 2.0*(1.0-(sum+sum2+l_ntb_2)/(2. * opOrder));

        if(sym < *sym_min)
          { 
           *sym_min = sym; 
            dir_cos_min[0]=dir_cos[k-1][0];
            dir_cos_min[1]=dir_cos[k-1][1];
            dir_cos_min[2]=dir_cos[k-1][2];
           }
      }
    }
}

