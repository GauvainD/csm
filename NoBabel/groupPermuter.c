/*
 * Author: shadi lahham
 *
 * generates permutations in the range 1 .. size
 * the permutations are generated by a group of permuters that
 * are "chained in a series" such that the effect is cumulative.
 *
 */

#include <stdio.h> // REMOVE LATER
#include <stdlib.h>  // for NULL
#include "groupPermuter.h"

/*
 * creates a groupPermuter of size totalSize
 * numberOfGroups - number of permutation groups
 * sizesOfGroups - array of the size of each group
 * permuationGroupSize - the 'n' gouped item size in a permutation, see permuter.c for details
 */
groupPermuter* createGroupPermuter(int numberOfGroups, int* sizesOfGroups, int totalSize, int permutationGroupSize, int addGroupsOfTwo){

    int i;

    // allocate groupPermuter
    groupPermuter *gp = (groupPermuter *)malloc(sizeof(groupPermuter));

    //set data members
    gp->_size = totalSize;
    gp->_numberOfGroups = numberOfGroups;
    gp->_sizesOfGroups = sizesOfGroups;

	//allocate index
    gp->_index = (int*)malloc(gp->_size * sizeof(int));

	// allocate permuters array
	gp->_permuters = (permuter**)malloc(numberOfGroups * sizeof(permuter*));

	// init permuters
	for ( i=0;  i< numberOfGroups ;  i++ ){
		gp->_permuters[i] = createPermuter(sizesOfGroups[i],permutationGroupSize, addGroupsOfTwo);
	}

	gp->_firstPermutation = TRUE;

    return gp;
}

void resetGroupPermuter(groupPermuter *gp) {
	int i = 0;
	for (i = 0; i < gp->_numberOfGroups; i++) {
		resetPermuter(gp->_permuters[i]);
	}
	gp->_firstPermutation = TRUE;
}

/*
 * copy permuter indexes to main index
 */
void copyIndexes(groupPermuter *gp){

	int i,j,pos,offset;
	pos = 0;
	offset = 0;

	for ( i=0;  i< gp->_numberOfGroups ;  i++ ){

		if (i>0)
				offset = offset + gp->_sizesOfGroups[i-1];

		for ( j=0;  j< gp->_sizesOfGroups[i] ;  j++ ){
			gp->_index[pos] = gp->_permuters[i]->_index[j] + offset;
			pos++;
		}
	}
}

/*
 * get the next valid permutation
 * in case of error or reached end of permutations, returns 0 (FALSE)
 */
int nextGroupPermutation(groupPermuter *gp){

	int i,j;

	// first permuation is unique, init all permuters
	if (gp->_firstPermutation){

		gp->_firstPermutation = FALSE;

		// init all permuters
		for ( i=0;  i< gp->_numberOfGroups ;  i++ ){
			if (! nextPermutation(gp->_permuters[i]) )
				// init failed
				return FALSE;
		}
		copyIndexes(gp);
		return TRUE;
	}

	// not first permutation, try to advance a permuter starting from the last one
	for ( i=gp->_numberOfGroups-1;  i >= 0 ;  i-- ){

		// if a permuter advances we've found a permutation
		if ( nextPermutation(gp->_permuters[i]) ){

			// reset the following permuters
			for ( j=i+1;  j <= gp->_numberOfGroups-1 ;  j++ ) {
				resetPermuter(gp->_permuters[j]);
				nextPermutation(gp->_permuters[j]);
			}
			copyIndexes(gp);
			return TRUE;
		}
	}

	// we failed to advance any of the counters
	return FALSE;

}

/*
 * free memory of the groupPermuter structure
 */
void freeGroupPermuter(groupPermuter *gp){

	int i;

    // free index
	free(gp->_index);

	// free permutes
	for ( i=0;  i< gp->_numberOfGroups ;  i++ ){
		freePermuter(gp->_permuters[i]);
	}
	free(gp->_permuters);

	//free groupPermuter
	free(gp);

};
