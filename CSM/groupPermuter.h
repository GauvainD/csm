/*
 * Author: shadi lahham
 *
 * generates permutations in the range 1 .. size
 * the permutations are generated by a group of permuters that
 * are "chained in a series" such that the effect is cumulative.
 *
 */

#ifndef GROUP_PERMUTER_H
#define GROUP_PERMUTER_H

#include "permuter.h"

/** 
 * The structure holding all the information about the permuters
 */
typedef struct groupPermuter {
	int _numberOfGroups;
	int* _sizesOfGroups;
    int _size;
    int* _index;
    permuter** _permuters;
	int _firstPermutation;  // boolean flag - the first permuation is unique, not permuted
} groupPermuter;

/** 
 * Create a group permuter for a single molecule, 
 * containing a permutation enumerator for each equivalence group
 *
 * @param numberOfGroups The number of equivalence groups in the molecule
 * @param sizesOfGroups The size of each group
 * @param totalSize The number of atoms in the molecule
 * @param permutationGroupSize The size of allowed cycles (in addition to cycles of size 1)
 * @param addGroupsOfTwo Should cycles of size 2 also be allowed
 * 
 * @return The new groupPermuter
 */
groupPermuter* createGroupPermuter(int numberOfGroups, int* sizesOfGroups, int totalSize, int permutationGroupSize, 
		int addGroupsOfTwo);

/**
 * Generate the next permutation
 * 
 * @param gp The groupPermuter object
 * 
 * @return TRUE if we have not yet reached the end of the enumerator, FALSE otherwise
 */
int nextGroupPermutation(groupPermuter *gp);

/** 
 * Reset the group permuter to re-initialize enumeration
 * 
 * @param gp The groupPermuter to reset
 */
void resetGroupPermuter(groupPermuter *gp);

/** 
 * Free all the allocated memory
 *
 * @param gp The groupPermuter to free
 */
void freeGroupPermuter(groupPermuter *gp);

#endif
