/*
 * Author: shadi lahham
 *
 * generates permutations in the range 1 .. size
 * the permutations are generated by a group of permuters that
 * are "chained in a series" such that the effect is cumulative.
 *
 */

#include <stdlib.h>
#include "groupPermuter.h"
#include <assert.h>

#include "logging.h"

/*
 * creates a groupPermuter of size totalSize
 * numberOfGroups - number of permutation groups
 * sizesOfGroups - array of the size of each group
 * permuationGroupSize - the 'n' gouped item size in a permutation, see permuter.c for details
 */
GroupPermuter::GroupPermuter(int numberOfGroups, int* sizesOfGroups, int totalSize, int permutationGroupSize, int addGroupsOfTwo){

    int i;

    //set data members
    _size = totalSize;
    _numberOfGroups = numberOfGroups;
    _sizesOfGroups = sizesOfGroups;

	//allocate index
    _index = (int*)malloc(_size * sizeof(int));

	// allocate permuters array
	_permuters = (Permuter**)malloc(numberOfGroups * sizeof(Permuter*));

	// init permuters
	for ( i=0;  i< numberOfGroups ;  i++ ){
		_permuters[i] = new Permuter(sizesOfGroups[i],permutationGroupSize, addGroupsOfTwo);
	}

	_firstPermutation = true;
}

void GroupPermuter::reset() 
{
	int i = 0;
	for (i = 0; i < _numberOfGroups; i++) {
		_permuters[i]->reset();
	}
	_firstPermutation = true;
}

/*
 * copy permuter indexes to main index
 */
void GroupPermuter::copyIndexes()
{

	int i,j,pos,offset;
	pos = 0;
	offset = 0;

	for ( i=0;  i< _numberOfGroups ;  i++ ){

		if (i>0)
				offset = offset + _sizesOfGroups[i-1];

		for ( j=0;  j< _sizesOfGroups[i] ;  j++ ){
			_index[pos] = _permuters[i]->elementAt(j) + offset;
			pos++;
		}
	}
}

/*
 * get the next valid permutation
 * in case of error or reached end of permutations, returns false
 */
bool GroupPermuter::next()
{
	static long numRuns = 0;
	int i,j;

	// first permuation is unique, init all permuters
	if (_firstPermutation){

		_firstPermutation = false;

		// init all permuters
		for ( i=0;  i< _numberOfGroups ;  i++ ){
			if (! _permuters[i]->next() )
				// init failed
				return false;
		}
		copyIndexes();
		//numRuns++;
		return true;
	}

	// not first permutation, try to advance a permuter starting from the last one
	for ( i=_numberOfGroups-1;  i >= 0 ;  i-- ){

		// if a permuter advances we've found a permutation
		if (_permuters[i]->next()){

			// reset the following permuters
			for ( j=i+1;  j <= _numberOfGroups-1 ;  j++ ) {
				_permuters[j]->reset();
				_permuters[j]->next();
			}
			copyIndexes();
			numRuns++;
			return true;
		}
	}

	// we failed to advance any of the counters
	LOG(debug) << "TotalPerms: " << numRuns;
	return false;

}

/*
 * free memory of the groupPermuter structure
 */
GroupPermuter::~GroupPermuter()
{

	int i;

    // free index
	free(_index);

	// free permutes
	for ( i=0;  i< _numberOfGroups ;  i++ ){
		delete _permuters[i];
	}
	free(_permuters);
};

const int GroupPermuter::operator[](int index) const
{
	assert(index >= 0 && index < _size);
	return _index[index];
}
